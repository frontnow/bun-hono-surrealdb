{
  "version": 3,
  "sources": ["../node_modules/hono/dist/compose.js", "../node_modules/hono/dist/utils/body.js", "../node_modules/hono/dist/utils/url.js", "../node_modules/hono/dist/request.js", "../node_modules/hono/dist/utils/html.js", "../node_modules/hono/dist/context.js", "../node_modules/hono/dist/router.js", "../node_modules/hono/dist/utils/constants.js", "../node_modules/hono/dist/hono-base.js", "../node_modules/hono/dist/router/reg-exp-router/node.js", "../node_modules/hono/dist/router/reg-exp-router/trie.js", "../node_modules/hono/dist/router/reg-exp-router/router.js", "../node_modules/hono/dist/router/smart-router/router.js", "../node_modules/hono/dist/router/trie-router/node.js", "../node_modules/hono/dist/router/trie-router/router.js", "../node_modules/hono/dist/hono.js", "../node_modules/hono/dist/middleware/timing/timing.js", "../node_modules/hono/dist/adapter/vercel/handler.js", "../src/index.ts"],
  "sourcesContent": [
    "// src/compose.ts\nvar compose = (middleware, onError, onNotFound) => {\n  return (context, next) => {\n    let index = -1;\n    return dispatch(0);\n    async function dispatch(i) {\n      if (i <= index) {\n        throw new Error(\"next() called multiple times\");\n      }\n      index = i;\n      let res;\n      let isError = false;\n      let handler;\n      if (middleware[i]) {\n        handler = middleware[i][0][0];\n        context.req.routeIndex = i;\n      } else {\n        handler = i === middleware.length && next || void 0;\n      }\n      if (handler) {\n        try {\n          res = await handler(context, () => dispatch(i + 1));\n        } catch (err) {\n          if (err instanceof Error && onError) {\n            context.error = err;\n            res = await onError(err, context);\n            isError = true;\n          } else {\n            throw err;\n          }\n        }\n      } else {\n        if (context.finalized === false && onNotFound) {\n          res = await onNotFound(context);\n        }\n      }\n      if (res && (context.finalized === false || isError)) {\n        context.res = res;\n      }\n      return context;\n    }\n  };\n};\nexport {\n  compose\n};\n",
    "// src/utils/body.ts\nimport { HonoRequest } from \"../request.js\";\nvar parseBody = async (request, options = /* @__PURE__ */ Object.create(null)) => {\n  const { all = false, dot = false } = options;\n  const headers = request instanceof HonoRequest ? request.raw.headers : request.headers;\n  const contentType = headers.get(\"Content-Type\");\n  if (contentType?.startsWith(\"multipart/form-data\") || contentType?.startsWith(\"application/x-www-form-urlencoded\")) {\n    return parseFormData(request, { all, dot });\n  }\n  return {};\n};\nasync function parseFormData(request, options) {\n  const formData = await request.formData();\n  if (formData) {\n    return convertFormDataToBodyData(formData, options);\n  }\n  return {};\n}\nfunction convertFormDataToBodyData(formData, options) {\n  const form = /* @__PURE__ */ Object.create(null);\n  formData.forEach((value, key) => {\n    const shouldParseAllValues = options.all || key.endsWith(\"[]\");\n    if (!shouldParseAllValues) {\n      form[key] = value;\n    } else {\n      handleParsingAllValues(form, key, value);\n    }\n  });\n  if (options.dot) {\n    Object.entries(form).forEach(([key, value]) => {\n      const shouldParseDotValues = key.includes(\".\");\n      if (shouldParseDotValues) {\n        handleParsingNestedValues(form, key, value);\n        delete form[key];\n      }\n    });\n  }\n  return form;\n}\nvar handleParsingAllValues = (form, key, value) => {\n  if (form[key] !== void 0) {\n    if (Array.isArray(form[key])) {\n      ;\n      form[key].push(value);\n    } else {\n      form[key] = [form[key], value];\n    }\n  } else {\n    form[key] = value;\n  }\n};\nvar handleParsingNestedValues = (form, key, value) => {\n  let nestedForm = form;\n  const keys = key.split(\".\");\n  keys.forEach((key2, index) => {\n    if (index === keys.length - 1) {\n      nestedForm[key2] = value;\n    } else {\n      if (!nestedForm[key2] || typeof nestedForm[key2] !== \"object\" || Array.isArray(nestedForm[key2]) || nestedForm[key2] instanceof File) {\n        nestedForm[key2] = /* @__PURE__ */ Object.create(null);\n      }\n      nestedForm = nestedForm[key2];\n    }\n  });\n};\nexport {\n  parseBody\n};\n",
    "// src/utils/url.ts\nvar splitPath = (path) => {\n  const paths = path.split(\"/\");\n  if (paths[0] === \"\") {\n    paths.shift();\n  }\n  return paths;\n};\nvar splitRoutingPath = (routePath) => {\n  const { groups, path } = extractGroupsFromPath(routePath);\n  const paths = splitPath(path);\n  return replaceGroupMarks(paths, groups);\n};\nvar extractGroupsFromPath = (path) => {\n  const groups = [];\n  path = path.replace(/\\{[^}]+\\}/g, (match, index) => {\n    const mark = `@${index}`;\n    groups.push([mark, match]);\n    return mark;\n  });\n  return { groups, path };\n};\nvar replaceGroupMarks = (paths, groups) => {\n  for (let i = groups.length - 1; i >= 0; i--) {\n    const [mark] = groups[i];\n    for (let j = paths.length - 1; j >= 0; j--) {\n      if (paths[j].includes(mark)) {\n        paths[j] = paths[j].replace(mark, groups[i][1]);\n        break;\n      }\n    }\n  }\n  return paths;\n};\nvar patternCache = {};\nvar getPattern = (label, next) => {\n  if (label === \"*\") {\n    return \"*\";\n  }\n  const match = label.match(/^\\:([^\\{\\}]+)(?:\\{(.+)\\})?$/);\n  if (match) {\n    const cacheKey = `${label}#${next}`;\n    if (!patternCache[cacheKey]) {\n      if (match[2]) {\n        patternCache[cacheKey] = next && next[0] !== \":\" && next[0] !== \"*\" ? [cacheKey, match[1], new RegExp(`^${match[2]}(?=/${next})`)] : [label, match[1], new RegExp(`^${match[2]}$`)];\n      } else {\n        patternCache[cacheKey] = [label, match[1], true];\n      }\n    }\n    return patternCache[cacheKey];\n  }\n  return null;\n};\nvar tryDecode = (str, decoder) => {\n  try {\n    return decoder(str);\n  } catch {\n    return str.replace(/(?:%[0-9A-Fa-f]{2})+/g, (match) => {\n      try {\n        return decoder(match);\n      } catch {\n        return match;\n      }\n    });\n  }\n};\nvar tryDecodeURI = (str) => tryDecode(str, decodeURI);\nvar getPath = (request) => {\n  const url = request.url;\n  const start = url.indexOf(\"/\", 8);\n  let i = start;\n  for (; i < url.length; i++) {\n    const charCode = url.charCodeAt(i);\n    if (charCode === 37) {\n      const queryIndex = url.indexOf(\"?\", i);\n      const path = url.slice(start, queryIndex === -1 ? void 0 : queryIndex);\n      return tryDecodeURI(path.includes(\"%25\") ? path.replace(/%25/g, \"%2525\") : path);\n    } else if (charCode === 63) {\n      break;\n    }\n  }\n  return url.slice(start, i);\n};\nvar getQueryStrings = (url) => {\n  const queryIndex = url.indexOf(\"?\", 8);\n  return queryIndex === -1 ? \"\" : \"?\" + url.slice(queryIndex + 1);\n};\nvar getPathNoStrict = (request) => {\n  const result = getPath(request);\n  return result.length > 1 && result.at(-1) === \"/\" ? result.slice(0, -1) : result;\n};\nvar mergePath = (base, sub, ...rest) => {\n  if (rest.length) {\n    sub = mergePath(sub, ...rest);\n  }\n  return `${base?.[0] === \"/\" ? \"\" : \"/\"}${base}${sub === \"/\" ? \"\" : `${base?.at(-1) === \"/\" ? \"\" : \"/\"}${sub?.[0] === \"/\" ? sub.slice(1) : sub}`}`;\n};\nvar checkOptionalParameter = (path) => {\n  if (!path.match(/\\:.+\\?$/)) {\n    return null;\n  }\n  const segments = path.split(\"/\");\n  const results = [];\n  let basePath = \"\";\n  segments.forEach((segment) => {\n    if (segment !== \"\" && !/\\:/.test(segment)) {\n      basePath += \"/\" + segment;\n    } else if (/\\:/.test(segment)) {\n      if (/\\?/.test(segment)) {\n        if (results.length === 0 && basePath === \"\") {\n          results.push(\"/\");\n        } else {\n          results.push(basePath);\n        }\n        const optionalSegment = segment.replace(\"?\", \"\");\n        basePath += \"/\" + optionalSegment;\n        results.push(basePath);\n      } else {\n        basePath += \"/\" + segment;\n      }\n    }\n  });\n  return results.filter((v, i, a) => a.indexOf(v) === i);\n};\nvar _decodeURI = (value) => {\n  if (!/[%+]/.test(value)) {\n    return value;\n  }\n  if (value.indexOf(\"+\") !== -1) {\n    value = value.replace(/\\+/g, \" \");\n  }\n  return value.indexOf(\"%\") !== -1 ? decodeURIComponent_(value) : value;\n};\nvar _getQueryParam = (url, key, multiple) => {\n  let encoded;\n  if (!multiple && key && !/[%+]/.test(key)) {\n    let keyIndex2 = url.indexOf(`?${key}`, 8);\n    if (keyIndex2 === -1) {\n      keyIndex2 = url.indexOf(`&${key}`, 8);\n    }\n    while (keyIndex2 !== -1) {\n      const trailingKeyCode = url.charCodeAt(keyIndex2 + key.length + 1);\n      if (trailingKeyCode === 61) {\n        const valueIndex = keyIndex2 + key.length + 2;\n        const endIndex = url.indexOf(\"&\", valueIndex);\n        return _decodeURI(url.slice(valueIndex, endIndex === -1 ? void 0 : endIndex));\n      } else if (trailingKeyCode == 38 || isNaN(trailingKeyCode)) {\n        return \"\";\n      }\n      keyIndex2 = url.indexOf(`&${key}`, keyIndex2 + 1);\n    }\n    encoded = /[%+]/.test(url);\n    if (!encoded) {\n      return void 0;\n    }\n  }\n  const results = {};\n  encoded ??= /[%+]/.test(url);\n  let keyIndex = url.indexOf(\"?\", 8);\n  while (keyIndex !== -1) {\n    const nextKeyIndex = url.indexOf(\"&\", keyIndex + 1);\n    let valueIndex = url.indexOf(\"=\", keyIndex);\n    if (valueIndex > nextKeyIndex && nextKeyIndex !== -1) {\n      valueIndex = -1;\n    }\n    let name = url.slice(\n      keyIndex + 1,\n      valueIndex === -1 ? nextKeyIndex === -1 ? void 0 : nextKeyIndex : valueIndex\n    );\n    if (encoded) {\n      name = _decodeURI(name);\n    }\n    keyIndex = nextKeyIndex;\n    if (name === \"\") {\n      continue;\n    }\n    let value;\n    if (valueIndex === -1) {\n      value = \"\";\n    } else {\n      value = url.slice(valueIndex + 1, nextKeyIndex === -1 ? void 0 : nextKeyIndex);\n      if (encoded) {\n        value = _decodeURI(value);\n      }\n    }\n    if (multiple) {\n      if (!(results[name] && Array.isArray(results[name]))) {\n        results[name] = [];\n      }\n      ;\n      results[name].push(value);\n    } else {\n      results[name] ??= value;\n    }\n  }\n  return key ? results[key] : results;\n};\nvar getQueryParam = _getQueryParam;\nvar getQueryParams = (url, key) => {\n  return _getQueryParam(url, key, true);\n};\nvar decodeURIComponent_ = decodeURIComponent;\nexport {\n  checkOptionalParameter,\n  decodeURIComponent_,\n  getPath,\n  getPathNoStrict,\n  getPattern,\n  getQueryParam,\n  getQueryParams,\n  getQueryStrings,\n  mergePath,\n  splitPath,\n  splitRoutingPath,\n  tryDecode\n};\n",
    "// src/request.ts\nimport { parseBody } from \"./utils/body.js\";\nimport { decodeURIComponent_, getQueryParam, getQueryParams, tryDecode } from \"./utils/url.js\";\nvar tryDecodeURIComponent = (str) => tryDecode(str, decodeURIComponent_);\nvar HonoRequest = class {\n  raw;\n  #validatedData;\n  #matchResult;\n  routeIndex = 0;\n  path;\n  bodyCache = {};\n  constructor(request, path = \"/\", matchResult = [[]]) {\n    this.raw = request;\n    this.path = path;\n    this.#matchResult = matchResult;\n    this.#validatedData = {};\n  }\n  param(key) {\n    return key ? this.#getDecodedParam(key) : this.#getAllDecodedParams();\n  }\n  #getDecodedParam(key) {\n    const paramKey = this.#matchResult[0][this.routeIndex][1][key];\n    const param = this.#getParamValue(paramKey);\n    return param ? /\\%/.test(param) ? tryDecodeURIComponent(param) : param : void 0;\n  }\n  #getAllDecodedParams() {\n    const decoded = {};\n    const keys = Object.keys(this.#matchResult[0][this.routeIndex][1]);\n    for (const key of keys) {\n      const value = this.#getParamValue(this.#matchResult[0][this.routeIndex][1][key]);\n      if (value && typeof value === \"string\") {\n        decoded[key] = /\\%/.test(value) ? tryDecodeURIComponent(value) : value;\n      }\n    }\n    return decoded;\n  }\n  #getParamValue(paramKey) {\n    return this.#matchResult[1] ? this.#matchResult[1][paramKey] : paramKey;\n  }\n  query(key) {\n    return getQueryParam(this.url, key);\n  }\n  queries(key) {\n    return getQueryParams(this.url, key);\n  }\n  header(name) {\n    if (name) {\n      return this.raw.headers.get(name) ?? void 0;\n    }\n    const headerData = {};\n    this.raw.headers.forEach((value, key) => {\n      headerData[key] = value;\n    });\n    return headerData;\n  }\n  async parseBody(options) {\n    return this.bodyCache.parsedBody ??= await parseBody(this, options);\n  }\n  #cachedBody = (key) => {\n    const { bodyCache, raw } = this;\n    const cachedBody = bodyCache[key];\n    if (cachedBody) {\n      return cachedBody;\n    }\n    const anyCachedKey = Object.keys(bodyCache)[0];\n    if (anyCachedKey) {\n      return bodyCache[anyCachedKey].then((body) => {\n        if (anyCachedKey === \"json\") {\n          body = JSON.stringify(body);\n        }\n        return new Response(body)[key]();\n      });\n    }\n    return bodyCache[key] = raw[key]();\n  };\n  json() {\n    return this.#cachedBody(\"json\");\n  }\n  text() {\n    return this.#cachedBody(\"text\");\n  }\n  arrayBuffer() {\n    return this.#cachedBody(\"arrayBuffer\");\n  }\n  blob() {\n    return this.#cachedBody(\"blob\");\n  }\n  formData() {\n    return this.#cachedBody(\"formData\");\n  }\n  addValidatedData(target, data) {\n    this.#validatedData[target] = data;\n  }\n  valid(target) {\n    return this.#validatedData[target];\n  }\n  get url() {\n    return this.raw.url;\n  }\n  get method() {\n    return this.raw.method;\n  }\n  get matchedRoutes() {\n    return this.#matchResult[0].map(([[, route]]) => route);\n  }\n  get routePath() {\n    return this.#matchResult[0].map(([[, route]]) => route)[this.routeIndex].path;\n  }\n};\nexport {\n  HonoRequest\n};\n",
    "// src/utils/html.ts\nvar HtmlEscapedCallbackPhase = {\n  Stringify: 1,\n  BeforeStream: 2,\n  Stream: 3\n};\nvar raw = (value, callbacks) => {\n  const escapedString = new String(value);\n  escapedString.isEscaped = true;\n  escapedString.callbacks = callbacks;\n  return escapedString;\n};\nvar escapeRe = /[&<>'\"]/;\nvar stringBufferToString = async (buffer, callbacks) => {\n  let str = \"\";\n  callbacks ||= [];\n  const resolvedBuffer = await Promise.all(buffer);\n  for (let i = resolvedBuffer.length - 1; ; i--) {\n    str += resolvedBuffer[i];\n    i--;\n    if (i < 0) {\n      break;\n    }\n    let r = resolvedBuffer[i];\n    if (typeof r === \"object\") {\n      callbacks.push(...r.callbacks || []);\n    }\n    const isEscaped = r.isEscaped;\n    r = await (typeof r === \"object\" ? r.toString() : r);\n    if (typeof r === \"object\") {\n      callbacks.push(...r.callbacks || []);\n    }\n    if (r.isEscaped ?? isEscaped) {\n      str += r;\n    } else {\n      const buf = [str];\n      escapeToBuffer(r, buf);\n      str = buf[0];\n    }\n  }\n  return raw(str, callbacks);\n};\nvar escapeToBuffer = (str, buffer) => {\n  const match = str.search(escapeRe);\n  if (match === -1) {\n    buffer[0] += str;\n    return;\n  }\n  let escape;\n  let index;\n  let lastIndex = 0;\n  for (index = match; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34:\n        escape = \"&quot;\";\n        break;\n      case 39:\n        escape = \"&#39;\";\n        break;\n      case 38:\n        escape = \"&amp;\";\n        break;\n      case 60:\n        escape = \"&lt;\";\n        break;\n      case 62:\n        escape = \"&gt;\";\n        break;\n      default:\n        continue;\n    }\n    buffer[0] += str.substring(lastIndex, index) + escape;\n    lastIndex = index + 1;\n  }\n  buffer[0] += str.substring(lastIndex, index);\n};\nvar resolveCallbackSync = (str) => {\n  const callbacks = str.callbacks;\n  if (!callbacks?.length) {\n    return str;\n  }\n  const buffer = [str];\n  const context = {};\n  callbacks.forEach((c) => c({ phase: HtmlEscapedCallbackPhase.Stringify, buffer, context }));\n  return buffer[0];\n};\nvar resolveCallback = async (str, phase, preserveCallbacks, context, buffer) => {\n  if (typeof str === \"object\" && !(str instanceof String)) {\n    if (!(str instanceof Promise)) {\n      str = str.toString();\n    }\n    if (str instanceof Promise) {\n      str = await str;\n    }\n  }\n  const callbacks = str.callbacks;\n  if (!callbacks?.length) {\n    return Promise.resolve(str);\n  }\n  if (buffer) {\n    buffer[0] += str;\n  } else {\n    buffer = [str];\n  }\n  const resStr = Promise.all(callbacks.map((c) => c({ phase, buffer, context }))).then(\n    (res) => Promise.all(\n      res.filter(Boolean).map((str2) => resolveCallback(str2, phase, false, context, buffer))\n    ).then(() => buffer[0])\n  );\n  if (preserveCallbacks) {\n    return raw(await resStr, callbacks);\n  } else {\n    return resStr;\n  }\n};\nexport {\n  HtmlEscapedCallbackPhase,\n  escapeToBuffer,\n  raw,\n  resolveCallback,\n  resolveCallbackSync,\n  stringBufferToString\n};\n",
    "// src/context.ts\nimport { HonoRequest } from \"./request.js\";\nimport { HtmlEscapedCallbackPhase, resolveCallback } from \"./utils/html.js\";\nvar TEXT_PLAIN = \"text/plain; charset=UTF-8\";\nvar setHeaders = (headers, map = {}) => {\n  for (const key of Object.keys(map)) {\n    headers.set(key, map[key]);\n  }\n  return headers;\n};\nvar Context = class {\n  #rawRequest;\n  #req;\n  env = {};\n  #var;\n  finalized = false;\n  error;\n  #status = 200;\n  #executionCtx;\n  #headers;\n  #preparedHeaders;\n  #res;\n  #isFresh = true;\n  #layout;\n  #renderer;\n  #notFoundHandler;\n  #matchResult;\n  #path;\n  constructor(req, options) {\n    this.#rawRequest = req;\n    if (options) {\n      this.#executionCtx = options.executionCtx;\n      this.env = options.env;\n      this.#notFoundHandler = options.notFoundHandler;\n      this.#path = options.path;\n      this.#matchResult = options.matchResult;\n    }\n  }\n  get req() {\n    this.#req ??= new HonoRequest(this.#rawRequest, this.#path, this.#matchResult);\n    return this.#req;\n  }\n  get event() {\n    if (this.#executionCtx && \"respondWith\" in this.#executionCtx) {\n      return this.#executionCtx;\n    } else {\n      throw Error(\"This context has no FetchEvent\");\n    }\n  }\n  get executionCtx() {\n    if (this.#executionCtx) {\n      return this.#executionCtx;\n    } else {\n      throw Error(\"This context has no ExecutionContext\");\n    }\n  }\n  get res() {\n    this.#isFresh = false;\n    return this.#res ||= new Response(\"404 Not Found\", { status: 404 });\n  }\n  set res(_res) {\n    this.#isFresh = false;\n    if (this.#res && _res) {\n      try {\n        for (const [k, v] of this.#res.headers.entries()) {\n          if (k === \"content-type\") {\n            continue;\n          }\n          if (k === \"set-cookie\") {\n            const cookies = this.#res.headers.getSetCookie();\n            _res.headers.delete(\"set-cookie\");\n            for (const cookie of cookies) {\n              _res.headers.append(\"set-cookie\", cookie);\n            }\n          } else {\n            _res.headers.set(k, v);\n          }\n        }\n      } catch (e) {\n        if (e instanceof TypeError && e.message.includes(\"immutable\")) {\n          this.res = new Response(_res.body, {\n            headers: _res.headers,\n            status: _res.status\n          });\n          return;\n        } else {\n          throw e;\n        }\n      }\n    }\n    this.#res = _res;\n    this.finalized = true;\n  }\n  render = (...args) => {\n    this.#renderer ??= (content) => this.html(content);\n    return this.#renderer(...args);\n  };\n  setLayout = (layout) => this.#layout = layout;\n  getLayout = () => this.#layout;\n  setRenderer = (renderer) => {\n    this.#renderer = renderer;\n  };\n  header = (name, value, options) => {\n    if (value === void 0) {\n      if (this.#headers) {\n        this.#headers.delete(name);\n      } else if (this.#preparedHeaders) {\n        delete this.#preparedHeaders[name.toLocaleLowerCase()];\n      }\n      if (this.finalized) {\n        this.res.headers.delete(name);\n      }\n      return;\n    }\n    if (options?.append) {\n      if (!this.#headers) {\n        this.#isFresh = false;\n        this.#headers = new Headers(this.#preparedHeaders);\n        this.#preparedHeaders = {};\n      }\n      this.#headers.append(name, value);\n    } else {\n      if (this.#headers) {\n        this.#headers.set(name, value);\n      } else {\n        this.#preparedHeaders ??= {};\n        this.#preparedHeaders[name.toLowerCase()] = value;\n      }\n    }\n    if (this.finalized) {\n      if (options?.append) {\n        this.res.headers.append(name, value);\n      } else {\n        this.res.headers.set(name, value);\n      }\n    }\n  };\n  status = (status) => {\n    this.#isFresh = false;\n    this.#status = status;\n  };\n  set = (key, value) => {\n    this.#var ??= /* @__PURE__ */ new Map();\n    this.#var.set(key, value);\n  };\n  get = (key) => {\n    return this.#var ? this.#var.get(key) : void 0;\n  };\n  get var() {\n    if (!this.#var) {\n      return {};\n    }\n    return Object.fromEntries(this.#var);\n  }\n  #newResponse(data, arg, headers) {\n    if (this.#isFresh && !headers && !arg && this.#status === 200) {\n      return new Response(data, {\n        headers: this.#preparedHeaders\n      });\n    }\n    if (arg && typeof arg !== \"number\") {\n      const header = new Headers(arg.headers);\n      if (this.#headers) {\n        this.#headers.forEach((v, k) => {\n          if (k === \"set-cookie\") {\n            header.append(k, v);\n          } else {\n            header.set(k, v);\n          }\n        });\n      }\n      const headers2 = setHeaders(header, this.#preparedHeaders);\n      return new Response(data, {\n        headers: headers2,\n        status: arg.status ?? this.#status\n      });\n    }\n    const status = typeof arg === \"number\" ? arg : this.#status;\n    this.#preparedHeaders ??= {};\n    this.#headers ??= new Headers();\n    setHeaders(this.#headers, this.#preparedHeaders);\n    if (this.#res) {\n      this.#res.headers.forEach((v, k) => {\n        if (k === \"set-cookie\") {\n          this.#headers?.append(k, v);\n        } else {\n          this.#headers?.set(k, v);\n        }\n      });\n      setHeaders(this.#headers, this.#preparedHeaders);\n    }\n    headers ??= {};\n    for (const [k, v] of Object.entries(headers)) {\n      if (typeof v === \"string\") {\n        this.#headers.set(k, v);\n      } else {\n        this.#headers.delete(k);\n        for (const v2 of v) {\n          this.#headers.append(k, v2);\n        }\n      }\n    }\n    return new Response(data, {\n      status,\n      headers: this.#headers\n    });\n  }\n  newResponse = (...args) => this.#newResponse(...args);\n  body = (data, arg, headers) => {\n    return typeof arg === \"number\" ? this.#newResponse(data, arg, headers) : this.#newResponse(data, arg);\n  };\n  text = (text, arg, headers) => {\n    if (!this.#preparedHeaders) {\n      if (this.#isFresh && !headers && !arg) {\n        return new Response(text);\n      }\n      this.#preparedHeaders = {};\n    }\n    this.#preparedHeaders[\"content-type\"] = TEXT_PLAIN;\n    if (typeof arg === \"number\") {\n      return this.#newResponse(text, arg, headers);\n    }\n    return this.#newResponse(text, arg);\n  };\n  json = (object, arg, headers) => {\n    const body = JSON.stringify(object);\n    this.#preparedHeaders ??= {};\n    this.#preparedHeaders[\"content-type\"] = \"application/json\";\n    return typeof arg === \"number\" ? this.#newResponse(body, arg, headers) : this.#newResponse(body, arg);\n  };\n  html = (html, arg, headers) => {\n    this.#preparedHeaders ??= {};\n    this.#preparedHeaders[\"content-type\"] = \"text/html; charset=UTF-8\";\n    if (typeof html === \"object\") {\n      return resolveCallback(html, HtmlEscapedCallbackPhase.Stringify, false, {}).then((html2) => {\n        return typeof arg === \"number\" ? this.#newResponse(html2, arg, headers) : this.#newResponse(html2, arg);\n      });\n    }\n    return typeof arg === \"number\" ? this.#newResponse(html, arg, headers) : this.#newResponse(html, arg);\n  };\n  redirect = (location, status) => {\n    this.#headers ??= new Headers();\n    this.#headers.set(\"Location\", String(location));\n    return this.newResponse(null, status ?? 302);\n  };\n  notFound = () => {\n    this.#notFoundHandler ??= () => new Response();\n    return this.#notFoundHandler(this);\n  };\n};\nexport {\n  Context,\n  TEXT_PLAIN\n};\n",
    "// src/router.ts\nvar METHOD_NAME_ALL = \"ALL\";\nvar METHOD_NAME_ALL_LOWERCASE = \"all\";\nvar METHODS = [\"get\", \"post\", \"put\", \"delete\", \"options\", \"patch\"];\nvar MESSAGE_MATCHER_IS_ALREADY_BUILT = \"Can not add a route since the matcher is already built.\";\nvar UnsupportedPathError = class extends Error {\n};\nexport {\n  MESSAGE_MATCHER_IS_ALREADY_BUILT,\n  METHODS,\n  METHOD_NAME_ALL,\n  METHOD_NAME_ALL_LOWERCASE,\n  UnsupportedPathError\n};\n",
    "// src/utils/constants.ts\nvar COMPOSED_HANDLER = \"__COMPOSED_HANDLER\";\nexport {\n  COMPOSED_HANDLER\n};\n",
    "// src/hono-base.ts\nimport { compose } from \"./compose.js\";\nimport { Context } from \"./context.js\";\nimport { METHODS, METHOD_NAME_ALL, METHOD_NAME_ALL_LOWERCASE } from \"./router.js\";\nimport { COMPOSED_HANDLER } from \"./utils/constants.js\";\nimport { getPath, getPathNoStrict, mergePath } from \"./utils/url.js\";\nvar notFoundHandler = (c) => {\n  return c.text(\"404 Not Found\", 404);\n};\nvar errorHandler = (err, c) => {\n  if (\"getResponse\" in err) {\n    return err.getResponse();\n  }\n  console.error(err);\n  return c.text(\"Internal Server Error\", 500);\n};\nvar Hono = class {\n  get;\n  post;\n  put;\n  delete;\n  options;\n  patch;\n  all;\n  on;\n  use;\n  router;\n  getPath;\n  _basePath = \"/\";\n  #path = \"/\";\n  routes = [];\n  constructor(options = {}) {\n    const allMethods = [...METHODS, METHOD_NAME_ALL_LOWERCASE];\n    allMethods.forEach((method) => {\n      this[method] = (args1, ...args) => {\n        if (typeof args1 === \"string\") {\n          this.#path = args1;\n        } else {\n          this.#addRoute(method, this.#path, args1);\n        }\n        args.forEach((handler) => {\n          this.#addRoute(method, this.#path, handler);\n        });\n        return this;\n      };\n    });\n    this.on = (method, path, ...handlers) => {\n      for (const p of [path].flat()) {\n        this.#path = p;\n        for (const m of [method].flat()) {\n          handlers.map((handler) => {\n            this.#addRoute(m.toUpperCase(), this.#path, handler);\n          });\n        }\n      }\n      return this;\n    };\n    this.use = (arg1, ...handlers) => {\n      if (typeof arg1 === \"string\") {\n        this.#path = arg1;\n      } else {\n        this.#path = \"*\";\n        handlers.unshift(arg1);\n      }\n      handlers.forEach((handler) => {\n        this.#addRoute(METHOD_NAME_ALL, this.#path, handler);\n      });\n      return this;\n    };\n    const strict = options.strict ?? true;\n    delete options.strict;\n    Object.assign(this, options);\n    this.getPath = strict ? options.getPath ?? getPath : getPathNoStrict;\n  }\n  #clone() {\n    const clone = new Hono({\n      router: this.router,\n      getPath: this.getPath\n    });\n    clone.routes = this.routes;\n    return clone;\n  }\n  #notFoundHandler = notFoundHandler;\n  errorHandler = errorHandler;\n  route(path, app) {\n    const subApp = this.basePath(path);\n    app.routes.map((r) => {\n      let handler;\n      if (app.errorHandler === errorHandler) {\n        handler = r.handler;\n      } else {\n        handler = async (c, next) => (await compose([], app.errorHandler)(c, () => r.handler(c, next))).res;\n        handler[COMPOSED_HANDLER] = r.handler;\n      }\n      subApp.#addRoute(r.method, r.path, handler);\n    });\n    return this;\n  }\n  basePath(path) {\n    const subApp = this.#clone();\n    subApp._basePath = mergePath(this._basePath, path);\n    return subApp;\n  }\n  onError = (handler) => {\n    this.errorHandler = handler;\n    return this;\n  };\n  notFound = (handler) => {\n    this.#notFoundHandler = handler;\n    return this;\n  };\n  mount(path, applicationHandler, options) {\n    let replaceRequest;\n    let optionHandler;\n    if (options) {\n      if (typeof options === \"function\") {\n        optionHandler = options;\n      } else {\n        optionHandler = options.optionHandler;\n        replaceRequest = options.replaceRequest;\n      }\n    }\n    const getOptions = optionHandler ? (c) => {\n      const options2 = optionHandler(c);\n      return Array.isArray(options2) ? options2 : [options2];\n    } : (c) => {\n      let executionContext = void 0;\n      try {\n        executionContext = c.executionCtx;\n      } catch {\n      }\n      return [c.env, executionContext];\n    };\n    replaceRequest ||= (() => {\n      const mergedPath = mergePath(this._basePath, path);\n      const pathPrefixLength = mergedPath === \"/\" ? 0 : mergedPath.length;\n      return (request) => {\n        const url = new URL(request.url);\n        url.pathname = url.pathname.slice(pathPrefixLength) || \"/\";\n        return new Request(url, request);\n      };\n    })();\n    const handler = async (c, next) => {\n      const res = await applicationHandler(replaceRequest(c.req.raw), ...getOptions(c));\n      if (res) {\n        return res;\n      }\n      await next();\n    };\n    this.#addRoute(METHOD_NAME_ALL, mergePath(path, \"*\"), handler);\n    return this;\n  }\n  #addRoute(method, path, handler) {\n    method = method.toUpperCase();\n    path = mergePath(this._basePath, path);\n    const r = { path, method, handler };\n    this.router.add(method, path, [handler, r]);\n    this.routes.push(r);\n  }\n  #handleError(err, c) {\n    if (err instanceof Error) {\n      return this.errorHandler(err, c);\n    }\n    throw err;\n  }\n  #dispatch(request, executionCtx, env, method) {\n    if (method === \"HEAD\") {\n      return (async () => new Response(null, await this.#dispatch(request, executionCtx, env, \"GET\")))();\n    }\n    const path = this.getPath(request, { env });\n    const matchResult = this.router.match(method, path);\n    const c = new Context(request, {\n      path,\n      matchResult,\n      env,\n      executionCtx,\n      notFoundHandler: this.#notFoundHandler\n    });\n    if (matchResult[0].length === 1) {\n      let res;\n      try {\n        res = matchResult[0][0][0][0](c, async () => {\n          c.res = await this.#notFoundHandler(c);\n        });\n      } catch (err) {\n        return this.#handleError(err, c);\n      }\n      return res instanceof Promise ? res.then(\n        (resolved) => resolved || (c.finalized ? c.res : this.#notFoundHandler(c))\n      ).catch((err) => this.#handleError(err, c)) : res ?? this.#notFoundHandler(c);\n    }\n    const composed = compose(matchResult[0], this.errorHandler, this.#notFoundHandler);\n    return (async () => {\n      try {\n        const context = await composed(c);\n        if (!context.finalized) {\n          throw new Error(\n            \"Context is not finalized. Did you forget to return a Response object or `await next()`?\"\n          );\n        }\n        return context.res;\n      } catch (err) {\n        return this.#handleError(err, c);\n      }\n    })();\n  }\n  fetch = (request, ...rest) => {\n    return this.#dispatch(request, rest[1], rest[0], request.method);\n  };\n  request = (input, requestInit, Env, executionCtx) => {\n    if (input instanceof Request) {\n      return this.fetch(requestInit ? new Request(input, requestInit) : input, Env, executionCtx);\n    }\n    input = input.toString();\n    return this.fetch(\n      new Request(\n        /^https?:\\/\\//.test(input) ? input : `http://localhost${mergePath(\"/\", input)}`,\n        requestInit\n      ),\n      Env,\n      executionCtx\n    );\n  };\n  fire = () => {\n    addEventListener(\"fetch\", (event) => {\n      event.respondWith(this.#dispatch(event.request, event, void 0, event.request.method));\n    });\n  };\n};\nexport {\n  Hono as HonoBase\n};\n",
    "// src/router/reg-exp-router/node.ts\nvar LABEL_REG_EXP_STR = \"[^/]+\";\nvar ONLY_WILDCARD_REG_EXP_STR = \".*\";\nvar TAIL_WILDCARD_REG_EXP_STR = \"(?:|/.*)\";\nvar PATH_ERROR = Symbol();\nvar regExpMetaChars = new Set(\".\\\\+*[^]$()\");\nfunction compareKey(a, b) {\n  if (a.length === 1) {\n    return b.length === 1 ? a < b ? -1 : 1 : -1;\n  }\n  if (b.length === 1) {\n    return 1;\n  }\n  if (a === ONLY_WILDCARD_REG_EXP_STR || a === TAIL_WILDCARD_REG_EXP_STR) {\n    return 1;\n  } else if (b === ONLY_WILDCARD_REG_EXP_STR || b === TAIL_WILDCARD_REG_EXP_STR) {\n    return -1;\n  }\n  if (a === LABEL_REG_EXP_STR) {\n    return 1;\n  } else if (b === LABEL_REG_EXP_STR) {\n    return -1;\n  }\n  return a.length === b.length ? a < b ? -1 : 1 : b.length - a.length;\n}\nvar Node = class {\n  #index;\n  #varIndex;\n  #children = /* @__PURE__ */ Object.create(null);\n  insert(tokens, index, paramMap, context, pathErrorCheckOnly) {\n    if (tokens.length === 0) {\n      if (this.#index !== void 0) {\n        throw PATH_ERROR;\n      }\n      if (pathErrorCheckOnly) {\n        return;\n      }\n      this.#index = index;\n      return;\n    }\n    const [token, ...restTokens] = tokens;\n    const pattern = token === \"*\" ? restTokens.length === 0 ? [\"\", \"\", ONLY_WILDCARD_REG_EXP_STR] : [\"\", \"\", LABEL_REG_EXP_STR] : token === \"/*\" ? [\"\", \"\", TAIL_WILDCARD_REG_EXP_STR] : token.match(/^\\:([^\\{\\}]+)(?:\\{(.+)\\})?$/);\n    let node;\n    if (pattern) {\n      const name = pattern[1];\n      let regexpStr = pattern[2] || LABEL_REG_EXP_STR;\n      if (name && pattern[2]) {\n        regexpStr = regexpStr.replace(/^\\((?!\\?:)(?=[^)]+\\)$)/, \"(?:\");\n        if (/\\((?!\\?:)/.test(regexpStr)) {\n          throw PATH_ERROR;\n        }\n      }\n      node = this.#children[regexpStr];\n      if (!node) {\n        if (Object.keys(this.#children).some(\n          (k) => k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR\n        )) {\n          throw PATH_ERROR;\n        }\n        if (pathErrorCheckOnly) {\n          return;\n        }\n        node = this.#children[regexpStr] = new Node();\n        if (name !== \"\") {\n          node.#varIndex = context.varIndex++;\n        }\n      }\n      if (!pathErrorCheckOnly && name !== \"\") {\n        paramMap.push([name, node.#varIndex]);\n      }\n    } else {\n      node = this.#children[token];\n      if (!node) {\n        if (Object.keys(this.#children).some(\n          (k) => k.length > 1 && k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR\n        )) {\n          throw PATH_ERROR;\n        }\n        if (pathErrorCheckOnly) {\n          return;\n        }\n        node = this.#children[token] = new Node();\n      }\n    }\n    node.insert(restTokens, index, paramMap, context, pathErrorCheckOnly);\n  }\n  buildRegExpStr() {\n    const childKeys = Object.keys(this.#children).sort(compareKey);\n    const strList = childKeys.map((k) => {\n      const c = this.#children[k];\n      return (typeof c.#varIndex === \"number\" ? `(${k})@${c.#varIndex}` : regExpMetaChars.has(k) ? `\\\\${k}` : k) + c.buildRegExpStr();\n    });\n    if (typeof this.#index === \"number\") {\n      strList.unshift(`#${this.#index}`);\n    }\n    if (strList.length === 0) {\n      return \"\";\n    }\n    if (strList.length === 1) {\n      return strList[0];\n    }\n    return \"(?:\" + strList.join(\"|\") + \")\";\n  }\n};\nexport {\n  Node,\n  PATH_ERROR\n};\n",
    "// src/router/reg-exp-router/trie.ts\nimport { Node } from \"./node.js\";\nvar Trie = class {\n  #context = { varIndex: 0 };\n  #root = new Node();\n  insert(path, index, pathErrorCheckOnly) {\n    const paramAssoc = [];\n    const groups = [];\n    for (let i = 0; ; ) {\n      let replaced = false;\n      path = path.replace(/\\{[^}]+\\}/g, (m) => {\n        const mark = `@\\\\${i}`;\n        groups[i] = [mark, m];\n        i++;\n        replaced = true;\n        return mark;\n      });\n      if (!replaced) {\n        break;\n      }\n    }\n    const tokens = path.match(/(?::[^\\/]+)|(?:\\/\\*$)|./g) || [];\n    for (let i = groups.length - 1; i >= 0; i--) {\n      const [mark] = groups[i];\n      for (let j = tokens.length - 1; j >= 0; j--) {\n        if (tokens[j].indexOf(mark) !== -1) {\n          tokens[j] = tokens[j].replace(mark, groups[i][1]);\n          break;\n        }\n      }\n    }\n    this.#root.insert(tokens, index, paramAssoc, this.#context, pathErrorCheckOnly);\n    return paramAssoc;\n  }\n  buildRegExp() {\n    let regexp = this.#root.buildRegExpStr();\n    if (regexp === \"\") {\n      return [/^$/, [], []];\n    }\n    let captureIndex = 0;\n    const indexReplacementMap = [];\n    const paramReplacementMap = [];\n    regexp = regexp.replace(/#(\\d+)|@(\\d+)|\\.\\*\\$/g, (_, handlerIndex, paramIndex) => {\n      if (handlerIndex !== void 0) {\n        indexReplacementMap[++captureIndex] = Number(handlerIndex);\n        return \"$()\";\n      }\n      if (paramIndex !== void 0) {\n        paramReplacementMap[Number(paramIndex)] = ++captureIndex;\n        return \"\";\n      }\n      return \"\";\n    });\n    return [new RegExp(`^${regexp}`), indexReplacementMap, paramReplacementMap];\n  }\n};\nexport {\n  Trie\n};\n",
    "// src/router/reg-exp-router/router.ts\nimport {\n  MESSAGE_MATCHER_IS_ALREADY_BUILT,\n  METHOD_NAME_ALL,\n  UnsupportedPathError\n} from \"../../router.js\";\nimport { checkOptionalParameter } from \"../../utils/url.js\";\nimport { PATH_ERROR } from \"./node.js\";\nimport { Trie } from \"./trie.js\";\nvar emptyParam = [];\nvar nullMatcher = [/^$/, [], /* @__PURE__ */ Object.create(null)];\nvar wildcardRegExpCache = /* @__PURE__ */ Object.create(null);\nfunction buildWildcardRegExp(path) {\n  return wildcardRegExpCache[path] ??= new RegExp(\n    path === \"*\" ? \"\" : `^${path.replace(\n      /\\/\\*$|([.\\\\+*[^\\]$()])/g,\n      (_, metaChar) => metaChar ? `\\\\${metaChar}` : \"(?:|/.*)\"\n    )}$`\n  );\n}\nfunction clearWildcardRegExpCache() {\n  wildcardRegExpCache = /* @__PURE__ */ Object.create(null);\n}\nfunction buildMatcherFromPreprocessedRoutes(routes) {\n  const trie = new Trie();\n  const handlerData = [];\n  if (routes.length === 0) {\n    return nullMatcher;\n  }\n  const routesWithStaticPathFlag = routes.map(\n    (route) => [!/\\*|\\/:/.test(route[0]), ...route]\n  ).sort(\n    ([isStaticA, pathA], [isStaticB, pathB]) => isStaticA ? 1 : isStaticB ? -1 : pathA.length - pathB.length\n  );\n  const staticMap = /* @__PURE__ */ Object.create(null);\n  for (let i = 0, j = -1, len = routesWithStaticPathFlag.length; i < len; i++) {\n    const [pathErrorCheckOnly, path, handlers] = routesWithStaticPathFlag[i];\n    if (pathErrorCheckOnly) {\n      staticMap[path] = [handlers.map(([h]) => [h, /* @__PURE__ */ Object.create(null)]), emptyParam];\n    } else {\n      j++;\n    }\n    let paramAssoc;\n    try {\n      paramAssoc = trie.insert(path, j, pathErrorCheckOnly);\n    } catch (e) {\n      throw e === PATH_ERROR ? new UnsupportedPathError(path) : e;\n    }\n    if (pathErrorCheckOnly) {\n      continue;\n    }\n    handlerData[j] = handlers.map(([h, paramCount]) => {\n      const paramIndexMap = /* @__PURE__ */ Object.create(null);\n      paramCount -= 1;\n      for (; paramCount >= 0; paramCount--) {\n        const [key, value] = paramAssoc[paramCount];\n        paramIndexMap[key] = value;\n      }\n      return [h, paramIndexMap];\n    });\n  }\n  const [regexp, indexReplacementMap, paramReplacementMap] = trie.buildRegExp();\n  for (let i = 0, len = handlerData.length; i < len; i++) {\n    for (let j = 0, len2 = handlerData[i].length; j < len2; j++) {\n      const map = handlerData[i][j]?.[1];\n      if (!map) {\n        continue;\n      }\n      const keys = Object.keys(map);\n      for (let k = 0, len3 = keys.length; k < len3; k++) {\n        map[keys[k]] = paramReplacementMap[map[keys[k]]];\n      }\n    }\n  }\n  const handlerMap = [];\n  for (const i in indexReplacementMap) {\n    handlerMap[i] = handlerData[indexReplacementMap[i]];\n  }\n  return [regexp, handlerMap, staticMap];\n}\nfunction findMiddleware(middleware, path) {\n  if (!middleware) {\n    return void 0;\n  }\n  for (const k of Object.keys(middleware).sort((a, b) => b.length - a.length)) {\n    if (buildWildcardRegExp(k).test(path)) {\n      return [...middleware[k]];\n    }\n  }\n  return void 0;\n}\nvar RegExpRouter = class {\n  name = \"RegExpRouter\";\n  #middleware;\n  #routes;\n  constructor() {\n    this.#middleware = { [METHOD_NAME_ALL]: /* @__PURE__ */ Object.create(null) };\n    this.#routes = { [METHOD_NAME_ALL]: /* @__PURE__ */ Object.create(null) };\n  }\n  add(method, path, handler) {\n    const middleware = this.#middleware;\n    const routes = this.#routes;\n    if (!middleware || !routes) {\n      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);\n    }\n    if (!middleware[method]) {\n      ;\n      [middleware, routes].forEach((handlerMap) => {\n        handlerMap[method] = /* @__PURE__ */ Object.create(null);\n        Object.keys(handlerMap[METHOD_NAME_ALL]).forEach((p) => {\n          handlerMap[method][p] = [...handlerMap[METHOD_NAME_ALL][p]];\n        });\n      });\n    }\n    if (path === \"/*\") {\n      path = \"*\";\n    }\n    const paramCount = (path.match(/\\/:/g) || []).length;\n    if (/\\*$/.test(path)) {\n      const re = buildWildcardRegExp(path);\n      if (method === METHOD_NAME_ALL) {\n        Object.keys(middleware).forEach((m) => {\n          middleware[m][path] ||= findMiddleware(middleware[m], path) || findMiddleware(middleware[METHOD_NAME_ALL], path) || [];\n        });\n      } else {\n        middleware[method][path] ||= findMiddleware(middleware[method], path) || findMiddleware(middleware[METHOD_NAME_ALL], path) || [];\n      }\n      Object.keys(middleware).forEach((m) => {\n        if (method === METHOD_NAME_ALL || method === m) {\n          Object.keys(middleware[m]).forEach((p) => {\n            re.test(p) && middleware[m][p].push([handler, paramCount]);\n          });\n        }\n      });\n      Object.keys(routes).forEach((m) => {\n        if (method === METHOD_NAME_ALL || method === m) {\n          Object.keys(routes[m]).forEach(\n            (p) => re.test(p) && routes[m][p].push([handler, paramCount])\n          );\n        }\n      });\n      return;\n    }\n    const paths = checkOptionalParameter(path) || [path];\n    for (let i = 0, len = paths.length; i < len; i++) {\n      const path2 = paths[i];\n      Object.keys(routes).forEach((m) => {\n        if (method === METHOD_NAME_ALL || method === m) {\n          routes[m][path2] ||= [\n            ...findMiddleware(middleware[m], path2) || findMiddleware(middleware[METHOD_NAME_ALL], path2) || []\n          ];\n          routes[m][path2].push([handler, paramCount - len + i + 1]);\n        }\n      });\n    }\n  }\n  match(method, path) {\n    clearWildcardRegExpCache();\n    const matchers = this.#buildAllMatchers();\n    this.match = (method2, path2) => {\n      const matcher = matchers[method2] || matchers[METHOD_NAME_ALL];\n      const staticMatch = matcher[2][path2];\n      if (staticMatch) {\n        return staticMatch;\n      }\n      const match = path2.match(matcher[0]);\n      if (!match) {\n        return [[], emptyParam];\n      }\n      const index = match.indexOf(\"\", 1);\n      return [matcher[1][index], match];\n    };\n    return this.match(method, path);\n  }\n  #buildAllMatchers() {\n    const matchers = /* @__PURE__ */ Object.create(null);\n    Object.keys(this.#routes).concat(Object.keys(this.#middleware)).forEach((method) => {\n      matchers[method] ||= this.#buildMatcher(method);\n    });\n    this.#middleware = this.#routes = void 0;\n    return matchers;\n  }\n  #buildMatcher(method) {\n    const routes = [];\n    let hasOwnRoute = method === METHOD_NAME_ALL;\n    [this.#middleware, this.#routes].forEach((r) => {\n      const ownRoute = r[method] ? Object.keys(r[method]).map((path) => [path, r[method][path]]) : [];\n      if (ownRoute.length !== 0) {\n        hasOwnRoute ||= true;\n        routes.push(...ownRoute);\n      } else if (method !== METHOD_NAME_ALL) {\n        routes.push(\n          ...Object.keys(r[METHOD_NAME_ALL]).map((path) => [path, r[METHOD_NAME_ALL][path]])\n        );\n      }\n    });\n    if (!hasOwnRoute) {\n      return null;\n    } else {\n      return buildMatcherFromPreprocessedRoutes(routes);\n    }\n  }\n};\nexport {\n  RegExpRouter\n};\n",
    "// src/router/smart-router/router.ts\nimport { MESSAGE_MATCHER_IS_ALREADY_BUILT, UnsupportedPathError } from \"../../router.js\";\nvar SmartRouter = class {\n  name = \"SmartRouter\";\n  #routers = [];\n  #routes = [];\n  constructor(init) {\n    this.#routers = init.routers;\n  }\n  add(method, path, handler) {\n    if (!this.#routes) {\n      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);\n    }\n    this.#routes.push([method, path, handler]);\n  }\n  match(method, path) {\n    if (!this.#routes) {\n      throw new Error(\"Fatal error\");\n    }\n    const routers = this.#routers;\n    const routes = this.#routes;\n    const len = routers.length;\n    let i = 0;\n    let res;\n    for (; i < len; i++) {\n      const router = routers[i];\n      try {\n        for (let i2 = 0, len2 = routes.length; i2 < len2; i2++) {\n          router.add(...routes[i2]);\n        }\n        res = router.match(method, path);\n      } catch (e) {\n        if (e instanceof UnsupportedPathError) {\n          continue;\n        }\n        throw e;\n      }\n      this.match = router.match.bind(router);\n      this.#routers = [router];\n      this.#routes = void 0;\n      break;\n    }\n    if (i === len) {\n      throw new Error(\"Fatal error\");\n    }\n    this.name = `SmartRouter + ${this.activeRouter.name}`;\n    return res;\n  }\n  get activeRouter() {\n    if (this.#routes || this.#routers.length !== 1) {\n      throw new Error(\"No active router has been determined yet.\");\n    }\n    return this.#routers[0];\n  }\n};\nexport {\n  SmartRouter\n};\n",
    "// src/router/trie-router/node.ts\nimport { METHOD_NAME_ALL } from \"../../router.js\";\nimport { getPattern, splitPath, splitRoutingPath } from \"../../utils/url.js\";\nvar emptyParams = /* @__PURE__ */ Object.create(null);\nvar Node = class {\n  #methods;\n  #children;\n  #patterns;\n  #order = 0;\n  #params = emptyParams;\n  constructor(method, handler, children) {\n    this.#children = children || /* @__PURE__ */ Object.create(null);\n    this.#methods = [];\n    if (method && handler) {\n      const m = /* @__PURE__ */ Object.create(null);\n      m[method] = { handler, possibleKeys: [], score: 0 };\n      this.#methods = [m];\n    }\n    this.#patterns = [];\n  }\n  insert(method, path, handler) {\n    this.#order = ++this.#order;\n    let curNode = this;\n    const parts = splitRoutingPath(path);\n    const possibleKeys = [];\n    for (let i = 0, len = parts.length; i < len; i++) {\n      const p = parts[i];\n      const nextP = parts[i + 1];\n      const pattern = getPattern(p, nextP);\n      const key = Array.isArray(pattern) ? pattern[0] : p;\n      if (Object.keys(curNode.#children).includes(key)) {\n        curNode = curNode.#children[key];\n        const pattern2 = getPattern(p, nextP);\n        if (pattern2) {\n          possibleKeys.push(pattern2[1]);\n        }\n        continue;\n      }\n      curNode.#children[key] = new Node();\n      if (pattern) {\n        curNode.#patterns.push(pattern);\n        possibleKeys.push(pattern[1]);\n      }\n      curNode = curNode.#children[key];\n    }\n    const m = /* @__PURE__ */ Object.create(null);\n    const handlerSet = {\n      handler,\n      possibleKeys: possibleKeys.filter((v, i, a) => a.indexOf(v) === i),\n      score: this.#order\n    };\n    m[method] = handlerSet;\n    curNode.#methods.push(m);\n    return curNode;\n  }\n  #getHandlerSets(node, method, nodeParams, params) {\n    const handlerSets = [];\n    for (let i = 0, len = node.#methods.length; i < len; i++) {\n      const m = node.#methods[i];\n      const handlerSet = m[method] || m[METHOD_NAME_ALL];\n      const processedSet = {};\n      if (handlerSet !== void 0) {\n        handlerSet.params = /* @__PURE__ */ Object.create(null);\n        handlerSets.push(handlerSet);\n        if (nodeParams !== emptyParams || params && params !== emptyParams) {\n          for (let i2 = 0, len2 = handlerSet.possibleKeys.length; i2 < len2; i2++) {\n            const key = handlerSet.possibleKeys[i2];\n            const processed = processedSet[handlerSet.score];\n            handlerSet.params[key] = params?.[key] && !processed ? params[key] : nodeParams[key] ?? params?.[key];\n            processedSet[handlerSet.score] = true;\n          }\n        }\n      }\n    }\n    return handlerSets;\n  }\n  search(method, path) {\n    const handlerSets = [];\n    this.#params = emptyParams;\n    const curNode = this;\n    let curNodes = [curNode];\n    const parts = splitPath(path);\n    const curNodesQueue = [];\n    for (let i = 0, len = parts.length; i < len; i++) {\n      const part = parts[i];\n      const isLast = i === len - 1;\n      const tempNodes = [];\n      for (let j = 0, len2 = curNodes.length; j < len2; j++) {\n        const node = curNodes[j];\n        const nextNode = node.#children[part];\n        if (nextNode) {\n          nextNode.#params = node.#params;\n          if (isLast) {\n            if (nextNode.#children[\"*\"]) {\n              handlerSets.push(\n                ...this.#getHandlerSets(nextNode.#children[\"*\"], method, node.#params)\n              );\n            }\n            handlerSets.push(...this.#getHandlerSets(nextNode, method, node.#params));\n          } else {\n            tempNodes.push(nextNode);\n          }\n        }\n        for (let k = 0, len3 = node.#patterns.length; k < len3; k++) {\n          const pattern = node.#patterns[k];\n          const params = node.#params === emptyParams ? {} : { ...node.#params };\n          if (pattern === \"*\") {\n            const astNode = node.#children[\"*\"];\n            if (astNode) {\n              handlerSets.push(...this.#getHandlerSets(astNode, method, node.#params));\n              astNode.#params = params;\n              tempNodes.push(astNode);\n            }\n            continue;\n          }\n          if (part === \"\") {\n            continue;\n          }\n          const [key, name, matcher] = pattern;\n          const child = node.#children[key];\n          const restPathString = parts.slice(i).join(\"/\");\n          if (matcher instanceof RegExp) {\n            const m = matcher.exec(restPathString);\n            if (m) {\n              params[name] = m[0];\n              handlerSets.push(...this.#getHandlerSets(child, method, node.#params, params));\n              if (Object.keys(child.#children).length) {\n                child.#params = params;\n                const componentCount = m[0].match(/\\//)?.length ?? 0;\n                const targetCurNodes = curNodesQueue[componentCount] ||= [];\n                targetCurNodes.push(child);\n              }\n              continue;\n            }\n          }\n          if (matcher === true || matcher.test(part)) {\n            params[name] = part;\n            if (isLast) {\n              handlerSets.push(...this.#getHandlerSets(child, method, params, node.#params));\n              if (child.#children[\"*\"]) {\n                handlerSets.push(\n                  ...this.#getHandlerSets(child.#children[\"*\"], method, params, node.#params)\n                );\n              }\n            } else {\n              child.#params = params;\n              tempNodes.push(child);\n            }\n          }\n        }\n      }\n      curNodes = tempNodes.concat(curNodesQueue.shift() ?? []);\n    }\n    if (handlerSets.length > 1) {\n      handlerSets.sort((a, b) => {\n        return a.score - b.score;\n      });\n    }\n    return [handlerSets.map(({ handler, params }) => [handler, params])];\n  }\n};\nexport {\n  Node\n};\n",
    "// src/router/trie-router/router.ts\nimport { checkOptionalParameter } from \"../../utils/url.js\";\nimport { Node } from \"./node.js\";\nvar TrieRouter = class {\n  name = \"TrieRouter\";\n  #node;\n  constructor() {\n    this.#node = new Node();\n  }\n  add(method, path, handler) {\n    const results = checkOptionalParameter(path);\n    if (results) {\n      for (let i = 0, len = results.length; i < len; i++) {\n        this.#node.insert(method, results[i], handler);\n      }\n      return;\n    }\n    this.#node.insert(method, path, handler);\n  }\n  match(method, path) {\n    return this.#node.search(method, path);\n  }\n};\nexport {\n  TrieRouter\n};\n",
    "// src/hono.ts\nimport { HonoBase } from \"./hono-base.js\";\nimport { RegExpRouter } from \"./router/reg-exp-router/index.js\";\nimport { SmartRouter } from \"./router/smart-router/index.js\";\nimport { TrieRouter } from \"./router/trie-router/index.js\";\nvar Hono = class extends HonoBase {\n  constructor(options = {}) {\n    super(options);\n    this.router = options.router ?? new SmartRouter({\n      routers: [new RegExpRouter(), new TrieRouter()]\n    });\n  }\n};\nexport {\n  Hono\n};\n",
    "// src/middleware/timing/timing.ts\nimport \"../../context.js\";\nvar getTime = () => {\n  try {\n    return performance.now();\n  } catch {\n  }\n  return Date.now();\n};\nvar timing = (config) => {\n  const options = {\n    total: true,\n    enabled: true,\n    totalDescription: \"Total Response Time\",\n    autoEnd: true,\n    crossOrigin: false,\n    ...config\n  };\n  return async function timing2(c, next) {\n    const headers = [];\n    const timers = /* @__PURE__ */ new Map();\n    if (c.get(\"metric\")) {\n      return await next();\n    }\n    c.set(\"metric\", { headers, timers });\n    if (options.total) {\n      startTime(c, \"total\", options.totalDescription);\n    }\n    await next();\n    if (options.total) {\n      endTime(c, \"total\");\n    }\n    if (options.autoEnd) {\n      timers.forEach((_, key) => endTime(c, key));\n    }\n    const enabled = typeof options.enabled === \"function\" ? options.enabled(c) : options.enabled;\n    if (enabled) {\n      c.res.headers.append(\"Server-Timing\", headers.join(\",\"));\n      const crossOrigin = typeof options.crossOrigin === \"function\" ? options.crossOrigin(c) : options.crossOrigin;\n      if (crossOrigin) {\n        c.res.headers.append(\n          \"Timing-Allow-Origin\",\n          typeof crossOrigin === \"string\" ? crossOrigin : \"*\"\n        );\n      }\n    }\n  };\n};\nvar setMetric = (c, name, valueDescription, description, precision) => {\n  const metrics = c.get(\"metric\");\n  if (!metrics) {\n    console.warn(\"Metrics not initialized! Please add the `timing()` middleware to this route!\");\n    return;\n  }\n  if (typeof valueDescription === \"number\") {\n    const dur = valueDescription.toFixed(precision || 1);\n    const metric = description ? `${name};dur=${dur};desc=\"${description}\"` : `${name};dur=${dur}`;\n    metrics.headers.push(metric);\n  } else {\n    const metric = valueDescription ? `${name};desc=\"${valueDescription}\"` : `${name}`;\n    metrics.headers.push(metric);\n  }\n};\nvar startTime = (c, name, description) => {\n  const metrics = c.get(\"metric\");\n  if (!metrics) {\n    console.warn(\"Metrics not initialized! Please add the `timing()` middleware to this route!\");\n    return;\n  }\n  metrics.timers.set(name, { description, start: getTime() });\n};\nvar endTime = (c, name, precision) => {\n  const metrics = c.get(\"metric\");\n  if (!metrics) {\n    console.warn(\"Metrics not initialized! Please add the `timing()` middleware to this route!\");\n    return;\n  }\n  const timer = metrics.timers.get(name);\n  if (!timer) {\n    console.warn(`Timer \"${name}\" does not exist!`);\n    return;\n  }\n  const { description, start } = timer;\n  const duration = getTime() - start;\n  setMetric(c, name, duration, description, precision);\n  metrics.timers.delete(name);\n};\nexport {\n  endTime,\n  setMetric,\n  startTime,\n  timing\n};\n",
    "// src/adapter/vercel/handler.ts\nvar handle = (app) => (req) => {\n  return app.fetch(req);\n};\nexport {\n  handle\n};\n",
    "import { Hono } from \"hono\";\nimport { timing, setMetric, startTime, endTime } from \"hono/timing\";\nimport type { TimingVariables } from \"hono/timing\";\nimport { prettyJSON } from \"hono/pretty-json\";\nimport { languageDetector } from \"hono/language\";\nimport { logger } from \"hono/logger\";\nimport { cache } from \"hono/cache\";\nimport { serveStatic } from \"hono/bun\";\nimport { cors } from \"hono/cors\";\nimport {\n  getSurrealDB,\n  closeSurrealDB,\n  getProducts,\n  getProductById,\n} from \"./database\";\nimport { handle } from \"hono/vercel\";\n\nexport const runtime = \"edge\";\n\n// Type definitions for our app variables\ntype Variables = TimingVariables;\n\n// Define the app interface\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\n// Sample data\nconst users: User[] = [\n  { id: 1, name: \"John Doe\", email: \"john@example.com\" },\n  { id: 2, name: \"Jane Smith\", email: \"jane@example.com\" },\n  { id: 3, name: \"Bob Johnson\", email: \"bob@example.com\" },\n];\n\n// Create the Hono app\n// const app = new Hono<{ Variables: Variables }>().basePath(\"/api\");\n\n// // Apply middleware\n// app.use(\"*\", logger());\n// app.use(\"*\", prettyJSON());\n// app.use(\"*\", cors());\n// app.use(\n//   languageDetector({\n//     supportedLanguages: [\"en\", \"de\", \"fr\"],\n//     fallbackLanguage: \"en\",\n//   })\n// );\n\n// // Cache certain routes\n// app.get(\n//   \"/static/*\",\n//   cache({\n//     cacheName: \"static-assets\",\n//     cacheControl: \"max-age=3600\",\n//     wait: true,\n//   })\n// );\n\n// app.get(\n//   \"/api/*\",\n//   cache({\n//     cacheName: \"api\",\n//     cacheControl: \"max-age=3600\",\n//     wait: true,\n//   })\n// );\n\n// // Apply timing middleware\n// app.use(timing());\n\n// // Static file serving - create a public directory in your project root\n// app.use(\"/static/*\", serveStatic({ root: \"./\" }));\n\n// API Routes\nconst app = new Hono().basePath(\"/api\");\n\n\n// // Get all users\n// api.get(\"/users\", (c) => {\n//   return c.json(users);\n// });\n\n// // Get user by ID\n// api.get(\"/users/:id\", (c) => {\n//   const id = parseInt(c.req.param(\"id\"));\n//   const user = users.find((u) => u.id === id);\n\n//   if (!user) {\n//     return c.json({ error: \"User not found\" }, 404);\n//   }\n\n//   return c.json(user);\n// });\n\n// // Create a new user\n// api.post(\"/users\", async (c) => {\n//   const body = await c.req.json<Omit<User, \"id\">>();\n\n//   if (!body.name || !body.email) {\n//     return c.json({ error: \"Name and email are required\" }, 400);\n//   }\n\n//   const newUser: User = {\n//     id: users.length + 1,\n//     name: body.name,\n//     email: body.email,\n//   };\n\n//   users.push(newUser);\n//   return c.json(newUser, 201);\n// });\n\n// // Get all products with brand information\n// api.get(\"/products\", async (c) => {\n//   try {\n//     startTime(c, \"get-products\");\n//     const products = await getProducts();\n//     endTime(c, \"get-products\");\n\n//     return c.json({\n//       success: true,\n//       data: products,\n//     });\n//   } catch (error) {\n//     return c.json(\n//       {\n//         success: false,\n//         error: error instanceof Error ? error.message : String(error),\n//       },\n//       500\n//     );\n//   }\n// });\n\n// // Get product by ID\n// api.get(\"/products/:id\", async (c) => {\n//   try {\n//     const id = c.req.param(\"id\");\n//     startTime(c, \"get-product\");\n//     const product = await getProductById(id);\n//     endTime(c, \"get-product\");\n\n//     if (!product) {\n//       return c.json(\n//         {\n//           success: false,\n//           error: \"Product not found\",\n//         },\n//         404\n//       );\n//     }\n\n//     return c.json({\n//       success: true,\n//       data: product,\n//     });\n//   } catch (error) {\n//     return c.json(\n//       {\n//         success: false,\n//         error: error instanceof Error ? error.message : String(error),\n//       },\n//       500\n//     );\n//   }\n// });\n\n// // Mount the API under /api\n// app.route(\"/api\", api);\n\n// Home route with custom metrics\napp.get(\"/\", async (c) => {\n  // Start a new timer\n  startTime(c, \"db\");\n\n  // Simulate database operation\n  await new Promise((resolve) => setTimeout(resolve, 50));\n\n  // End the timer\n  endTime(c, \"db\");\n\n  const lang = c.get(\"language\");\n\n  return c.json({\n    message: \"Welcome to Hono with Bun!\",\n    language: lang,\n    endpoints: {\n      api: {\n        users: \"/api/users\",\n        userById: \"/api/users/:id\",\n      },\n      root: \"/\",\n    },\n  });\n});\n\nconst handler = handle(app);\n\nexport const GET = handler;\nexport const POST = handler;\nexport const PATCH = handler;\nexport const PUT = handler;\nexport const OPTIONS = handler;\n"
  ],
  "mappings": "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",
  "debugId": "E2E9404C91624B1364756E2164756E21",
  "names": []
}